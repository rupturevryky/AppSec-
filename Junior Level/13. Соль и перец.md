
>[!note] 
>**"соль" (salt)** и **"перец" (pepper)** — это два вида дополнительных секретных данных, которые используются для усиления защиты, но их роль и реализация кардинально различаются.

---
### "Соль" (Salt)

>[!note] **Определение:** 
>"Соль" — это **уникальная, случайная последовательность байтов**, которая генерируется отдельно для каждого пароля (или другой конфиденциальной информации) перед процессом его хеширования.

**Как применяется и для чего:**

1. **Уникальность:** Основная цель — гарантировать, что у каждого пароля, даже идентичного, будет уникальный хеш. Соль генерируется заново для каждого нового пользователя или при каждой смене пароля.
2. **Защита от предвычисленных атак:** Без соли злоумышленник может заранее рассчитать хеши для миллионов популярных паролей ("радужные таблицы") и мгновенно находить совпадения. Соль, будучи уникальной для каждой записи, делает такие таблицы бесполезными, так как для одного и того же пароля "password123" хеш будет совершенно разным из-за разной соли.
3. **Защита от анализа:** Не позволяет атакующему увидеть, у каких пользователей одинаковые пароли, так как даже они будут иметь разные хеши.

**Ключевые характеристики:**

- **Не является секретом:** Соль хранится в открытом виде прямо рядом с хешем пароля в базе данных. Её ценность не в секретности, а в уникальности и случайности.
- **Обязательна к использованию:** Использование соли сегодня считается абсолютным минимумом, стандартом де-факто при хранении любых паролей. Современные алгоритмы хеширования (bcrypt, Argon2) включают работу с солью по умолчанию.

---

### "Перец" (Pepper)

>[!note] **Определение:** 
>"Перец" — это **секретное криптографическое значение**, общее для всех паролей в системе, которое добавляется к паролю и соли перед хешированием.

**Как применяется и для чего:**

1. **Дополнительный секретный ингредиент:** Его цель — обеспечить дополнительный уровень защиты на случай полной компрометации базы данных хешей. Даже если атакующий украдет всю базу с хешами и солями, без знания "перца" он не сможет провести успешную атаку подбора.
2. **Защита от оффлайн-атак:** Атакующий, имея на руках базу хешей, не может начать подбор паролей, потому что ему неизвестна часть входных данных (перец). Это вынуждает его либо угадывать перец (что сложно, если он достаточно длинный и случайный), либо проводить атаку иначе.
    

**Ключевые характеристики:**

- **Является секретом:** Вся безопасность перца основана на его секретности. Он НЕ должен храниться в одной базе данных с хешами паролей.
    
- **Способ хранения — главный вопрос:**
    - **Вариант 1 (Рекомендуемый):** Хранить перец в строго защищённом месте, отдельно от базы данных паролей. Например, в аппаратном модуле безопасности (HSM), в секретах приложения (Kubernetes Secrets, HashiCorp Vault) или в переменных окружения на сервере приложений.
    - **Вариант 2 (Дискуссионный):** Небольшое количество перцев можно хешировать и хранить их хеши в базе, чтобы проверять правильность угадывания, но это усложняет архитектуру.

---

### Кардинальные технические различия

|Аспект|Соль (Salt)|Перец (Pepper)|
|---|---|---|
|**Основная цель**|Сделать каждый хеш уникальным, защита от предвычисленных атак.|Добавить секретный компонент, защита при компрометации БД.|
|**Уникальность**|**Уникальна для каждого пароля.**|**Общий для всех паролей в системе.**|
|**Секретность**|**Не секретна.** Хранится открыто рядом с хешем.|**Строго секретен.** Не должен храниться в БД с хешами.|
|**Обязательность**|**Обязательна.** Без соли хранение паролей считается небезопасным.|**Опциональна.** Дополнительная мера защиты для систем с повышенными требованиями.|
|**Влияние на архитектуру**|Минимальное. Логика полностью в рамках приложения и БД.|Существенное. Требует безопасного, отдельного механизма для хранения секрета.|
|**Что произойдет при компрометации?**|Если соль украдена вместе с хешами, это не снижает стойкости (если соль была уникальной). Атака продолжается методом грубой силы.|Если перец не был скомпрометирован, атака грубой силы становится невозможной или крайне затруднительной.|

---

### Резюме для AppSec-специалиста

1. **Соль — это ваш базовый уровень защиты.** Вы должны использовать её всегда. Убедитесь, что она криптографически стойкая, случайная и уникальная для каждой записи.
2. **Перец — это "оборонительный рубеж" на крайний случай.** Он защищает от сценария, когда злоумышленник получил полный дамп вашей базы данных. Его реализация сложнее и создает дополнительную точку управления секретами.
3. **Приоритеты:** Гораздо важнее убедиться, что вы используете современные, медленные алгоритмы хеширования (например, **Argon2id** или **bcrypt**), которые уже по умолчанию корректно работают с солью, чем внедрять перец на слабом алгоритме вроде MD5 или SHA-256.
4. **Риск перца:** Главный риск — создать единую точку отказа. Если вы потеряете перец, вы не сможете верифицировать ни один пароль в системе. Поэтому его хранение и резервное копирование должны быть организованы с высочайшей степенью надёжности.

Таким образом, "соль" делает атаку дорогой для каждого пароля по отдельности, а "перец" ставит перед атакующим дополнительную стену, требуя компрометации двух разных систем.

---

### Техническое представление "Соли" и "Перца"

>[!tip] **Соль (Salt):** 
>Технически, это **случайная последовательность байтов**. Обычно её представляют в виде строки, закодированной в Base64 или Hex. Длина современной соли должна быть не менее 128 бит (16 байт), что соответствует, например, 32 символам в Hex-кодировке.
>	- _Пример соли в Hex:_ `4acfe5d43560c4c4f`
>	- _Пример соли в Base64:_ `Ss/l1DVgxMTw`
>
>>[!warning] **Важно:** 
>>Эта строка **не является паролем или его производной**. Это абсолютно случайные данные, сгенерированные криптографически стойким генератором случайных чисел (CSPRNG).
    
>[!tip] **Перец (Pepper):** 
>Технически, перец — это тоже **случайная последовательность байтов**, аналогичная по длине и стойкости соли. Его ключевое отличие — в способе хранения и использования.
>    
 >   - _Пример перца (который вы никогда не увидите в БД):_ `a3dd4b6f8c12e1f7` (Hex)
        

---

### Процесс хеширования пароля с использованием Соли и Перца

Давайте рассмотрим схему на примере регистрации нового пользователя. В этом процессе участвуют три компонента:

1. **База данных (БД):** Хранит итоговый хеш и соль.
2. **Сервер приложения:** Выполняет логику хеширования.
3. **Хранилище секретов (для перца):** Например, HSM, Vault или переменные окружения.

---

#### Шаг 1: Регистрация пользователя (Создание хеша)

Допустим, пользователь создаёт пароль: `MySecretPassword123`.

1. **Генерация Соли:** Сервер приложения генерирует новую, уникальную соль для этого пользователя.
>  - `Соль = 4acfe5d43560c4c4f`
2. **Получение Перца:** Сервер приложения запрашивает перец из защищённого хранилища. Перец одинаков для всех пользователей.
>  - `Перец = a3dd4b6f8c12e1f7` (это значение никогда не покидает память сервера в идеальном сценарии и не пишется в БД).
3. **Конкатенация (Объединение):** Сервер объединяет все три компонента в одну строку. Порядок может быть разным, но общепринятый — пароль, затем соль, затем перец.
>  - `ИтоговаяСтрока = "MySecretPassword123" + "4acfe5d43560c4c4f" + "a3dd4b6f8c12e1f7"`
4. **Хеширование:** Эта объединённая строка передаётся на вход функции медленного, криптографически стойкого хеширования, такой как **bcrypt, Argon2 или PBKDF2**.
> - `ИтоговыйХеш = Argon2(ИтоговаяСтрока)`
> - Функция хеширования выполняет свою работу, включая тысячи итераций, чтобы замедлить подбор.
5. **Сохранение в БД:** Сервер сохраняет в базу данных две вещи:
> - **Хеш:** Полученный `ИтоговыйХеш`. Например: 
>   ```
>   $argon2id$v=19$m=65536,t=3,p=4$4acfe5d43560c4c4f$R8K...
>   ```
> - **Соль:** Открытую текстом `Соль` (`4acfe5d43560c4c4f`).
    
>[!warning] **Обратите внимание:** 
>**Перец в базу данных не сохраняется никогда.**

---

#### Шаг 2: Аутентификация пользователя (Проверка пароля)

Теперь пользователь пытается войти в систему, вводя пароль `MySecretPassword123`.

1. **Извлечение данных:** Сервер получает из базы данных `Хеш` и `Соль`, связанные с этим пользователем.
2. **Получение Перца:** Сервер снова запрашивает тот же самый общий `Перец` из защищённого хранилища.
3. **Повторная конкатенация:** Сервер объединяет введённый пароль, полученную из БД соль и полученный перец в том же самом порядке.
>- `ПроверяемаяСтрока = "MySecretPassword123" + "4acfe5d43560c4c4f" + "a3dd4b6f8c12e1f7"`
4. **Проверка:** Сервер вычисляет хеш от `ПроверяемойСтроки` с использованием тех же параметров (алгоритм, количество итераций), что и при регистрации.
>- `ПроверочныйХеш = Argon2(ПроверяемаяСтрока)`
5. **Сравнение:** Сервер сравнивает только что вычисленный `ПроверочныйХеш` с `ИтоговымХешом` из базы данных. Если они идентичны, пароль верен.

---
### Ключевые технические выводы для AppSec


>[!note] 1:
>**Соль видна всем, у кого есть доступ к БД.** Её сила в уникальности, а не в секретности. Она предотвращает использование радужных таблиц и заставляет атакующего подбирать каждый пароль по отдельности.

>[!note] 2:
>**Перец — это секрет приложения.** Его компрометация равносильна компрометации всего источника паролей. Его сила в том, что без него атакующий, имеющий на руках базу хешей и солей, не может даже начать атаку подбора.

>[!note] 3:
>**Порядок конкатенации должен быть фиксированным и одинаковым** на этапах регистрации и аутентификации.

>[!note] 4:
>**Использование перца не отменяет необходимости в соли.** Это дополнительные, взаимодополняющие меры защиты. Соль борется с предвычислением, перец — с последствиями утечки базы данных.

---