### Общий контекст: SSO (Single Sign-On)

>[!note] **Определение:** 
>**SSO** — это не протокол, а **архитектурный паттерн** (схема решения), который позволяет пользователю пройти аутентификацию один раз и получить доступ к нескольким связанным, но независимым приложениям и системам без повторного ввода учётных данных.

**Как применяется:** Пользователь входит в систему через центрального "поставщика удостоверений" (Identity Provider, IdP). После успешного входа любое другое приложение ("поставщик услуг", Service Provider, SP), которому пользователь пытается получить доступ, доверяет факт аутентификации от этого центрального поставщика.

**Плюсы:**

>- **Удобство пользователя:** Один пароль для всего.
>- **Безопасность:** Централизованное управление учётными записями, политиками паролей (сложность, срок действия) и MFA.
>- **Снижение рисков:** Упрощается процесс отзыва доступа (достаточно деактивировать одну учётную запись).
>- **Снижение затрат:** Меньше запросов в службу поддержки на сброс паролей.

**Минусы:**

>- **Единая точка отказа:** Если поставщик удостоверений падает, доступ ко всем связанным системам становится невозможен.
>- **Высокая цель для атаки:** Компрометация одной учётной записи даёт злоумышленнику доступ ко всем ресурсам, поэтому крайне важно защищать её по высшему стандарту (обязательный MFA).

---

### 1. SAML (Security Assertion Markup Language)

>[!note] **Определение:** 
>Это открытый стандарт на основе **XML** для обмена данными аутентификации и авторизации между поставщиком удостоверений (IdP) и поставщиком услуг (SP).

**Как применяется:** Классическая модель для корпоративных приложений. Пользователь пытается зайти в приложение (например, Salesforce), которое перенаправляет его в корпоративный IdP (например, Okta). После ввода учётных данных IdP генерирует подписанный XML-документ ("SAML Assertion"), который браузер пользователя передаёт обратно в приложение. Приложение проверяет подпись и "утверждение" (assertion) и пускает пользователя.

**Плюсы:**

>- **Зрелость и надёжность:** Стандарт существует давно, хорошо протестирован.
>- **Богатые возможности:** Передача большого количества атрибутов о пользователе в утверждении.
>- **Безопасность:** Сильная криптография на основе подписей XML, не зависит от транспортного уровня (HTTPS).

**Минусы:**

>- **Сложность:** XML канонизация, сложные подписи — это делает реализацию и отладку трудной.
>- **"Тяжеловесность":** SAML-ответы могут быть большими, их неудобно передавать в мобильных и SPA-приложениях.
>- **Ориентация на веб:** Сложно использовать в нативных мобильных приложениях или API-коммуникации.

---

### 2. OAuth 2.0 (Open Authorization 2.0)

>[!note] **Определение:** 
>Это **фреймворк авторизации**, а не аутентификации. Его цель — позволить приложению получать **ограниченный доступ** к ресурсам пользователя на другом сервисе, без раскрытия пароля пользователя.

**Как применяется:** Классический пример — "Войти через Facebook". Вы даёте стороннему приложению (например, Spotify) разрешение получить доступ к вашему списку друзей в Facebook или к вашему профилю. OAuth 2.0 управляет этим процессом делегирования прав. Пользователь аутентифицируется напрямую в Facebook (ресурсный сервер), который затем выдаёт приложению Spotify **токен доступа (Access Token)**. Spotify использует этот токен для вызова API Facebook от вашего имени.

>[!note]
>**Технические особенности:**
>1. Только HTTPS (без подписи запросов)
>2. Bearer Tokens (носительские токены)
>3. Refresh Tokens для продления доступа
>4. Scopes для ограничения прав

**Плюсы:**

>- **Гибкость:** Разные "потоки" (grants) для разных типов клиентов (веб-приложение, мобильное приложение, сервис).
>- **Идеален для API:** Легковесные JSON-токены идеально подходят для авторизации вызовов между сервисами.
>- **Безопасность делегирования:** Приложение не видит пароль пользователя.

**Минусы:**

>- **Уязвимость к реализации:** Ошибки в реализации (например, неправильная валидация redirect_uri, утечка токенов) приводят к серьёзным нарушениям безопасности.
>- **Не решает задачу аутентификации:** OAuth 2.0 не говорит приложению, _кто_ именно пользователь, он лишь говорит, что "держатель этого токена (bearer) имеет право X".

>[!note]
>**OAuth 1.0** — протокол для безопасного делегированного доступа к API без раскрытия паролей.
>
>**Технические отличия:**
>1. Сложная подпись запросов (HMAC-SHA1, RSA-SHA1)
>2. Токены доступа + секреты токенов
>3. Нет концепции refresh tokens
>4. Требует подписи каждого запроса

---
### 3. OpenID Connect (OIDC)

>[!note] **Определение:** 
>Это тонкий, но **критически важный** слой поверх OAuth 2.0, который добавляет функциональность **аутентификации**. По сути, он "замыкает" пробел OAuth 2.0, отвечая на вопрос "Кто этот пользователь?".

**Как применяется:** Используется в тех же сценариях, что и OAuth 2.0 ("Войти через Google"). Однако после того как пользователь даёт разрешение, сервер авторизации возвращает не только **токен доступа (Access Token)**, но и **ID Token**. Этот ID Token — это токен в формате JWT (JSON Web Token), который содержит "утверждения" (claims) о пользователе: его идентификатор, email, имя и т.д. Приложение может проверить подпись этого токена и быть уверенным, что пользователь аутентифицирован.

**Плюсы:**

>- **Простота:** Построен на JSON/JWT, что проще, чем SAML/XML.
>- **Универсальность:** Отлично работает для веб, мобильных приложений и API.
>- **Совмещает лучшее:** Даёт и факт аутентификации (как SAML), и механизм авторизации для API (как OAuth 2.0).
>- **Стандартизированная информация:** Стандартный набор claims в ID Token.

**Минусы:**

>- **Зависимость от JWT:** Требует корректной реализации валидации JWT, что может быть уязвимым местом.
>- **Меньше зрелости в enterprise:** В некоторых корпоративных средах с устоявшейся SAML-инфраструктурой может быть менее предпочтителен.

---

### Кардинальные технические различия

|Аспект|SAML|OAuth 2.0|OpenID Connect (OIDC)|
|---|---|---|---|
|**Основная цель**|**Аутентификация** и передача атрибутов|**Авторизация** (делегирование прав)|**Аутентификация** поверх OAuth 2.0|
|**Формат данных**|XML|JSON (и другие)|JSON (JWT)|
|**Транспорт**|Часто через браузер (POST-биндинг)|Любой (браузер, API-вызовы)|Любой (браузер, API-вызовы)|
|**Ключевой артефакт**|SAML Assertion (подписанный XML)|Access Token (не обязательно JWT)|**ID Token** (подписанный JWT) + Access Token|
|**Использование в API**|Сложно, не предназначен|**Идеально**|Идеально (через Access Token)|
|**Профиль использования**|Enterprise SSO|Авторизация для API, делегирование прав|Современный SSO, потребительская аутентификация|

---
### Резюме для AppSec-специалиста

- **Выбирайте SAML** для интеграции с legacy корпоративными системами, где требуется мощная передача атрибутов и есть устоявшаяся XML-инфраструктура.
- **Используйте OAuth 2.0**, когда ваше приложение нуждается в безопасном доступе к API другого сервиса _от имени пользователя_. Помните: это не про аутентификацию.
- **Выбирайте OpenID Connect** для любых современных сценариев входа пользователей (SSO для веб и мобильных приложений). Это де-факто современный стандарт, который решает и проблему аутентификации, и даёт инструмент для авторизации API.

С точки зрения безопасности, самыми частыми источниками уязвимостей во всех этих протоколах являются ошибки реализации: неправильная валидация подписей, открытые редиректы, утечка state-параметра в OAuth, неправильная конфигурация доверия между SP и IdP. Задача AppSec — не только выбрать правильный протокол, но и провести тщательный код-ревью и пентест его реализации.